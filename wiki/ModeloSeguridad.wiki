#summary Descripción de cómo manejar los datos en la apliación respecto de la seguridad.
#labels encryption,security,model,seguridad,encriptacion,token,auth,Featured,Phase-Implementation

= Modelo de Seguridad =

Los datos almacenados en la cookie y en `$_SESSION` deben estar encriptados en todo momento.  Para ello, la contraseña que se emplea depende de si el usuario está loggeado o no.

=== Contraseña de sistema con usuario loggeado ===

Cuando el usuario _está autenticado_, se emplea una contraseña que se forma con el SESSION_RANDOMTOKEN y el UID del usuario.
{{{
$usuario = new Usuario('nombre');
...
$session = new Session;
$session->setPassword($usuario->getUID());
$session->setPasswordSalt($usuario->getRandomToken());

$session->storeEnc($key, $value);
$session->retrieveEnc($key, $value);
}}}

=== Contraseña de sistema ===
Cuando el usuario no está autenticado, o bien se debe encriptar un valor que es requerido para autenticar al usuario, se emplea esta contraseña denominada _SystemPassword_.  La misma se forma en base a los tokens fijos que se encuentran en el archivo config.php y un string aleatorio que se genera la primera vez que el método apropiado es llamado.
P. E.: el nombre de usuario se almacena en `$_SESSION` de esta manera.

{{{
$session = new Session;
$session->useSystemPassword();

$session->storeEnc($key, $value);
$session->retrieveEnc($key, $value);
}}}

== Tokens ==
La aplicación utiliza diversos tokens para autenticar (session, page, password restore, etc), todos basados en principio en el mismo trait: _Token_trait_.

Los tokens están formados por:
 * Token constante definido en _config.php_
 * Random Token
 * Timestamp
 * Otro dato: 
  * Session Token, Password Restore Token: UID
  * Fingerprint Token: datos del navegador
  * Page Token: identificador de página

Se utilizan los métodos _get_ del objeto tipo Token que corresponda (session, fingerprint, page, etc) para obtener la información respectiva a Random Token, Timestamp y Token propiamente dicho.
Luego, se autentica comparando el valor del Token con el generado luego de usar los métodos _set_ del objeto, para insertar la información pertinente.  Dicho objeto incluye la función de autenticación (_authenticateToken_).  Éste método devuelve un valor booleano que debe usarse para autenticar (TRUE es válido, FALSE no).
Los Tokens se almacenan en la DB luego de que el usuario se loggea satisfactoriamente.

=== Form Token ===

El Random Token y Timestamp se almacenan en _SESSION_.  El Form Token se pasa a través de un campo oculto en el formulario.  Se autentica por el método apropiado.

==== Crear ====
{{{
$formToken = new FormToken;
$formToken->generateRandomToken();
$formToken->generateTimestamp();
$formToken->generateToken();
}}}
O bien
{{{
$formToken = new FormToken;
$formToken->generate();
}}}
Luego
{{{
Session::store(SMP_SESSINDEX_FORM_RANDOMTOKEN, $formToken->getRandomToken());
Session::store(SMP_SESSINDEX_FORM_TIMESTAMP, $formToken->getTimestamp());
}}}

==== Autenticar ====
{{{
$formToken = new FormToken;
$formToken->prepare_to_auth(Sanitizar::glPOST(SMP_SESSINDEX_FORM_TOKEN), 
                            Session::retrieve(SMP_SESSINDEX_FORM_RANDOMTOKEN), 
                            Session::retrieve(SMP_SESSINDEX_FORM_TIMESTAMP));

$formToken->authenticateToken() ? echo "token válido" : echo "token NO válido";
}}}

=== Session Token ===

A diferencia de los otros tokens, éste emplea el UID del usuario para validar de forma unívoca a la sesión, una vez que el usuario está loggeado.  No confundir con `$_SESSION` de PHP.
Los valores de Random Token y Timestamp se almacenan en la DB.  El Token, en _SESSION_.
Para autenticar, se lee de la DB los datos, se almacenan en el objeto y se emplea el método de autenticación para contrastar con el Token de _SESSION_.

_Manejado por la clase Usuario_

==== Crear ====
{{{
$sessToken = new SessionToken;
$sessToken->generateRandomToken();
$sessToken->generateTimestamp();
$sessToken->setUID(<user_UID_from_db>);
$sessToken->generateToken();

$sessToken->setTokenId(<user_TokenID>);
$sessToken->store_inDB_SessionToken();

Session::store(SMP_SESSINDEX_SESSIONKEY_TOKEN, $sessToken->getToken());
}}}

==== Autenticar ====
{{{
$sessToken = new SessionToken;
$sessToken->setUID(<user_UID_from_db>);
$sessToken->setTokenId(<user_TokenID>);
$sessToken->retrieve_fromDB_SessionToken();
$sessToken->setToken(Session::retrieve(SMP_SESSINDEX_SESSIONKEY_TOKEN));

$sessToken->authenticateToken() ? echo "token válido" : echo "token NO válido";
}}}

=== Page Token ===

El Random Token y Timestamp se almacenan en _SESSION_.  También se emplea un identificador de la página para generar el token, que puede ser su nombre o url.  El Page Token se pasa a través de la url (por GET).  Se autentica por el método apropiado.
_nav.php_ se encarga de generarlo.

==== Crear ====
{{{
$pageId = 'identificador de página';

$page = new Page;
$page->generateRandomToken();
$page->generateTimestamp();
$page->setLocation($pageId);
$page->generateToken();

Session::store(SMP_SESSINDEX_PAGE_RANDOMTOKEN, $page->getRandomToken());
Session::store(SMP_SESSINDEX_PAGE_TIMESTAMP, $page->getTimestamp());
}}}

==== Autenticar ====
{{{
$pageId = 'identificador de página';
}}}
{{{
$page = new Page($pageId, 
                 Session::retrieve(SMP_SESSINDEX_PAGE_RANDOMTOKEN), 
                 Session::retrieve(SMP_SESSINDEX_PAGE_TIMESTAMP), 
                 Sanitizar::glGET(SMP_SESSINDEX_PAGE_TOKEN));
}}}
Otra forma
{{{
$page = new Page
$page->prepare_to_auth(Sanitizar::glGET(SMP_SESSINDEX_PAGE_TOKEN), 
                       Session::retrieve(SMP_SESSINDEX_PAGE_RANDOMTOKEN), 
                       Session::retrieve(SMP_SESSINDEX_PAGE_TIMESTAMP),
                       $pageId);
}}}
Finalmente
{{{
$page->authenticateToken() ? echo "token auténtico" : echo "token NO auténtico!";
}}}

=== Password Restore Token ===

El Random Token y Timestamp se almacenan en la DB.  El Token se pasa a través de la URL, o bien mediante un formulario (fallback).  Se autentica con el método apropiado.

_Manejado por la clase Usuario_

==== Crear ====


==== Autenticar ====



=== Fingerprint Token ===

El Token se almacena en la DB.  Se emplean identificadores únicos del navegador del usuario y la IP (esto último dependiendo del modo _MODE_DONTUSEIP_ o _MODE_USEIP_).  Se autentica tomando el Token de la DB, y contrastando con el método apropiado.  El mismo debería mantenerse durante toda la sesión, si cambia implica un error (intento de hackeo?).
`Usuario::sesionIniciar()` se encarga de generarlo.

_Manejado por la clase Usuario_

==== Crear ====
{{{
$fingerprint = new Fingerprint;
}}}
Usando la IP del usuario
{{{
$fingerprint->setMode(Fingerprint::MODE_USEIP);
}}}
Sin considerar la IP
{{{
$fingerprint->setMode(Fingerprint::MODE_DONTUSEIP);
}}}
Luego
{{{
$fingerprint->generateToken();

$fingerprint->setTokenId($usuario->getTokenId());
$fingerprint->store_inDB();
}}}

==== Autenticar ====
{{{
$fingerprint = new Fingerprint;
$fingerprint->setTokenId($usuario->TokenId);
$fingerprint->retrieve_fromDB();
$fingerprint->authenticateToken() ? echo "Token auténtico" : echo "Token NO auténtico";
}}}


== Autenticar Usuario ==

=== Iniciar sesión ===
{{{
$username = 'nombre de usuario';
$passwd = 'contraseña en texto plano del usuario';

$usuario = new Usuario($username);
$usuario->setPassword($passwd);
if ($usuario->authenticatePassword()) {
    $usuario->sesionIniciar() ? echo "sesion iniciada" : echo "error al tratar de iniciar sesion";
} else {
    echo "usuario o contraseña incorrecta";
}
}}}
El nombre de usuario autenticado se almacena encriptado con SystemPassword en `$_SESSION[SMP_SESSINDEX_USERNAME]`.

=== Autenticar usuario / verificar que esté iniciada la sesión ===
{{{
$session = new Session;
$session->useSystemPassword();

$usuario = new Usuario($session->retrieveEnc(SMP_SESSINDEX_USERNAME));
if ($usuario->authenticateSession()) {
    echo "usuario autenticado, sesión iniciada";
} else {
    echo "usuario no válido!!";
}
}}}