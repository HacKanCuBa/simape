#summary Descripción de cómo manejar los datos en la apliación respecto de la seguridad.
#labels encryption,security,model,seguridad,encriptacion,token,auth,Featured,Phase-Implementation

= Modelo de Seguridad =

Resulta de vital importancia que el campo UID de la tabla Usuario NUNCA sea modificado, y sea asimismo único y totalmente aleatorio.  Se emplea por defecto un valor UUIDv4 por human-friendly readability.  Este parámetro se empleará en funciones de encriptación así como también de manejo de archivos.

== Encriptar, desencriptar y demás ==

A este fin se integran todas las funciones adecuadas en la clase _Crypto_, así como también la generación de valores aleatorios criptográficamente seguros.
Se emplean por defecto las funciones de [http://php.net/manual/es/ref.openssl.php OpenSSL].
Puede (des)encriptarse sin problemas tanto strings como valores numéricos, objetos, arrays, etc.  Cualquier tipo de datos soportado por PHP sin requerir procesamiento previo, y se asegura que el valor recuperado no será dañado.  Se emplea _(un)serialize_ y _base64`_`(en/de)code_ para almacenar todo como string.

{{{
$myPwd = 'password';
$mySalt = 'salt'; //opcional

$secStr = 'string secreto';
$encStr = Crypto::encrypt($secStr, $myPwd, $mySalt);
$decStr = Crypto::decrypt($encStr, $myPwd, $mySalt);
// $secStr == $decStr

$secObj = new ObjetoSecreto;
$encObj = Crypto::encrypt($secObj, $myPwd, $mySalt);
$decObj = Crypto::decrypt($encObj, $myPwd, $mySalt);
// $secObj == $decObj

// Puede omitirse la sal si no se desea emplearla
$encStr = Crypto::encrypt($secStr, $myPwd);
$decStr = Crypto::decrypt($encStr, $myPwd);
// $secStr == $decStr
}}}

Las funciones son inteligentes, y devolverán FALSE en caso de error.  P. E.: desencriptar algo que no estaba encriptado, o con la clave y/o sal incorrecta; encriptar algo con clave nula.
Puede encriptarse repetidas veces sin límite dentro de un bucle, pero esto no será más o menos seguro en absoluto, por lo que solo resulta en un gran gasto de procesador y tiempo.
Tanto la contraseña como la sal deben ser strings, o valores convertidos a strings.
Nota: se desaconseja emplear arrays, objetos u otros tipos de datos como contraseña/sal dado que el resultado puede ser totalmente inesperado.

== Sesión ==

Los datos almacenados en la cookie y en `$_SESSION` deben estar encriptados en todo momento.  Para ello, se genera una contraseña aleatoria al comienzo, y se encripta con una de dos contraseñas, dependiendo de si el usuario está loggeado o no.
Asimismo, para reforzar la seguridad, se emplea la ID de sesión como sal criptográfica, dado que la misma cambia (o no; por defecto lo hace) cada vez que se inicializa la sesión, esto es, en cada página cargada.

En términos generales, se puede emplear cualquier contraseña en la sesión de la siguiente manera:
{{{
$session = new Session;
$session->setPassword('contraseña');
$session->setPasswordSalt('sal_criptográfica');

$session->storeEnc($key, $value);
$value = $session->retrieveEnc($key);
}}}

Debe tenerse cuidado, dado que estos valores impactan directamente en la seguridad del sistema.  Es conveniente dejar que el sistema los maneje.  Para encriptar y desencriptar valores cualesquiera, referirse a la clase _Crypto_.

=== Contraseña de sistema con usuario loggeado ===

Cuando el usuario _está autenticado_, se emplea una contraseña que se forma con el UID del usuario y el identificador de sesión.
{{{
$usuario = new Usuario('nombre');
...
$session = new Session;
$session->useUserPassword($usuario->getUID());

$session->storeEnc($key, $value);
$value = $session->retrieveEnc($key);
}}}

=== Contraseña de sistema ===
Cuando el usuario no está autenticado, o bien se debe encriptar un valor que es requerido para autenticar al usuario, se emplea esta contraseña denominada _SystemPassword_.  La misma se forma en base a los tokens fijos que se encuentran en el archivo config.php y el identificador de sesión.
P. E.: el nombre de usuario se almacena en `$_SESSION` de esta manera.

{{{
$session = new Session;
$session->useSystemPassword();

$session->storeEnc($key, $value);
$value = $session->retrieveEnc($key);
}}}

== Tokens ==
La aplicación utiliza diversos tokens para autenticar (session, page, password restore, etc), todos basados en principio en el mismo trait: _Token_trait_.

Los tokens están formados por:
 * Token constante definido en _config.php_
 * Random Token
 * Timestamp
 * Otro dato: 
  * Session Token, Password Restore Token: UID
  * Fingerprint Token: datos del navegador
  * Page Token: identificador de página

Se utilizan los métodos _get_ del objeto tipo Token que corresponda (session, fingerprint, page, etc) para obtener la información respectiva a Random Token, Timestamp y Token propiamente dicho.
Luego, se autentica comparando el valor del Token con el generado luego de usar los métodos _set_ del objeto, para insertar la información pertinente.  Dicho objeto incluye la función de autenticación (_authenticateToken_).  Éste método devuelve un valor booleano que debe usarse para autenticar (TRUE es válido, FALSE no).
Los Tokens se almacenan en la DB luego de que el usuario se loggea satisfactoriamente.

=== Form Token ===

El Random Token y Timestamp se almacenan en _SESSION_.  El Form Token se pasa a través de un campo oculto en el formulario.  Se autentica por el método apropiado.

==== Crear ====
{{{
$formToken = new FormToken;
$formToken->generateRandomToken();
$formToken->generateTimestamp();
$formToken->generateToken();
}}}
O bien
{{{
$formToken = new FormToken;
$formToken->generate();
}}}
Luego
{{{
Session::store(SMP_SESSINDEX_FORM_RANDOMTOKEN, $formToken->getRandomToken());
Session::store(SMP_SESSINDEX_FORM_TIMESTAMP, $formToken->getTimestamp());
}}}

==== Autenticar ====
{{{
$formToken = new FormToken;
$formToken->prepare_to_auth(Sanitizar::glPOST(SMP_SESSINDEX_FORM_TOKEN), 
                            Session::retrieve(SMP_SESSINDEX_FORM_RANDOMTOKEN), 
                            Session::retrieve(SMP_SESSINDEX_FORM_TIMESTAMP));

$formToken->authenticateToken() ? echo "token válido" : echo "token NO válido";
}}}

=== Session Token ===

A diferencia de los otros tokens, éste emplea el UID del usuario para validar de forma unívoca a la sesión, una vez que el usuario está loggeado.  No confundir con `$_SESSION` de PHP.
Los valores de Random Token y Timestamp se almacenan en la DB.  El Token, en _SESSION_.
Para autenticar, se lee de la DB los datos, se almacenan en el objeto y se emplea el método de autenticación para contrastar con el Token de _SESSION_.

_Manejado por la clase Usuario_

==== Crear ====
{{{
$sessToken = new SessionToken;
$sessToken->generateRandomToken();
$sessToken->generateTimestamp();
$sessToken->setUID(<user_UID_from_db>);
$sessToken->generateToken();

$sessToken->setTokenId(<user_TokenID>);
$sessToken->store_inDB_SessionToken();

Session::store(SMP_SESSINDEX_SESSIONKEY_TOKEN, $sessToken->getToken());
}}}

==== Autenticar ====
{{{
$sessToken = new SessionToken;
$sessToken->setUID(<user_UID_from_db>);
$sessToken->setTokenId(<user_TokenID>);
$sessToken->retrieve_fromDB_SessionToken();
$sessToken->setToken(Session::retrieve(SMP_SESSINDEX_SESSIONKEY_TOKEN));

$sessToken->authenticateToken() ? echo "token válido" : echo "token NO válido";
}}}

=== Page Token ===

El Random Token y Timestamp se almacenan en _SESSION_.  También se emplea un identificador de la página para generar el token, que puede ser su nombre o url.  El Page Token se pasa a través de la url (por GET).  Se autentica por el método apropiado.
_nav.php_ se encarga de generarlo.

==== Crear ====
{{{
$pageId = 'identificador de página';

$page = new Page;
$page->generateRandomToken();
$page->generateTimestamp();
$page->setLocation($pageId);
$page->generateToken();

Session::store(SMP_SESSINDEX_PAGE_RANDOMTOKEN, $page->getRandomToken());
Session::store(SMP_SESSINDEX_PAGE_TIMESTAMP, $page->getTimestamp());
}}}

==== Autenticar ====
{{{
$pageId = 'identificador de página';
}}}
{{{
$page = new Page($pageId, 
                 Session::retrieve(SMP_SESSINDEX_PAGE_RANDOMTOKEN), 
                 Session::retrieve(SMP_SESSINDEX_PAGE_TIMESTAMP), 
                 Sanitizar::glGET(SMP_SESSINDEX_PAGE_TOKEN));
}}}
Otra forma
{{{
$page = new Page
$page->prepare_to_auth(Sanitizar::glGET(SMP_SESSINDEX_PAGE_TOKEN), 
                       Session::retrieve(SMP_SESSINDEX_PAGE_RANDOMTOKEN), 
                       Session::retrieve(SMP_SESSINDEX_PAGE_TIMESTAMP),
                       $pageId);
}}}
Finalmente
{{{
$page->authenticateToken() ? echo "token auténtico" : echo "token NO auténtico!";
}}}

=== Password Restore Token ===

El Random Token y Timestamp se almacenan en la DB.  El Token se pasa a través de la URL, o bien mediante un formulario (fallback).  Se autentica con el método apropiado.

_Manejado por la clase Usuario_

==== Crear ====


==== Autenticar ====



=== Fingerprint Token ===

El Token se almacena en la DB.  Se emplean identificadores únicos del navegador del usuario y la IP (esto último dependiendo del modo _MODE_DONTUSEIP_ o _MODE_USEIP_).  Se autentica tomando el Token de la DB, y contrastando con el método apropiado.  El mismo debería mantenerse durante toda la sesión, si cambia implica un error (intento de hackeo?).
`Usuario::sesionIniciar()` se encarga de generarlo.

_Manejado por la clase Usuario_

==== Crear ====
{{{
$fingerprint = new Fingerprint;
}}}
Usando la IP del usuario
{{{
$fingerprint->setMode(Fingerprint::MODE_USEIP);
}}}
Sin considerar la IP
{{{
$fingerprint->setMode(Fingerprint::MODE_DONTUSEIP);
}}}
Luego
{{{
$fingerprint->generateToken();

$fingerprint->setTokenId($usuario->getTokenId());
$fingerprint->store_inDB();
}}}

==== Autenticar ====
{{{
$fingerprint = new Fingerprint;
$fingerprint->setTokenId($usuario->TokenId);
$fingerprint->retrieve_fromDB();
$fingerprint->authenticateToken() ? echo "Token auténtico" : echo "Token NO auténtico";
}}}


== Autenticar Usuario ==

=== Iniciar sesión ===
{{{
$username = 'nombre de usuario';
$passwd = 'contraseña en texto plano del usuario';

$usuario = new Usuario($username);
$usuario->setPassword($passwd);
if ($usuario->authenticatePassword()) {
    $usuario->sesionIniciar() ? echo "sesion iniciada" : echo "error al tratar de iniciar sesion";
} else {
    echo "usuario o contraseña incorrecta";
}
}}}
El nombre de usuario autenticado se almacena encriptado con SystemPassword en `$_SESSION[SMP_SESSINDEX_USERNAME]`.

=== Autenticar usuario / verificar que esté iniciada la sesión ===
{{{
$session = new Session;
$session->useSystemPassword();

$usuario = new Usuario($session->retrieveEnc(SMP_SESSINDEX_USERNAME));
if ($usuario->authenticateSession()) {
    echo "usuario autenticado, sesión iniciada";
} else {
    echo "usuario no válido!!";
}
}}}